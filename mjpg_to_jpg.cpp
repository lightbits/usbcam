#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Create a valid JPG frame from a MJPG (motion JPG) frame by
// appending a default Huffman table to its header.
// USAGE
//   You allocate jpg with atleast mjpg_size + sizeof(huffman).
//   You can get just this value by passing NULL for 'jpg'.
//   The MJPG must have a Start of Frame marker (0xffc0).
// NOTES
//   Some cameras only support the MJPG format (V4L2_PIX_FMT_MJPEG)
// and not JPG format (V4L2_PIX_FMT_JPEG). Some cameras decide to
// output valid JPG frames anyway, while others, such as my webcam,
// decide to output nearly valid JPGs. Apparently, these would be
// valid JPGs if it were not for a missing Huffman table. Luckily,
// it is possible to just squeeze in some default table and get a
// perfectly fine JPG that way.
unsigned int mjpg_to_jpg(unsigned char *mjpg, unsigned int mjpg_size, unsigned char *jpg)
{
    // To understand how this works I suggest you run
    //   $ xxd <file> | less
    // on one of your MJPG images, and try to relate the binary data with
    // the JPEG specification on wikipedia (en.wikipedia.org/wiki/JPEG#JPEG_files).
    // Specifically, look for the ff** markers, starting with ffd8.
    // Then compare that with a JPG image.

    static unsigned char huffman[] =
    {
        // JPEG magic
        // 0xff, 0xd8,

        // Text comment
        // 0xff, 0xfe, 0x00, 0x10 0x4c, 0x61 0x76, 0x63 0x35, 0x36 0x2e, 0x36 0x30, 0x2e 0x31, 0x30 0x30, 0x00,

        // Huffman table
        0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00,
        0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01,
        0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
        0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24,
        0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
        0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
        0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
        0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,
        0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
        0xfa, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01,
        0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07,
        0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33,
        0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19,
        0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85,
        0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
        0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
        0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,
        0xf7, 0xf8, 0xf9, 0xfa
    };

    unsigned int jpg_size = mjpg_size+sizeof(huffman);
    if (!jpg)
        return jpg_size;

    // search for Start of Frame (SOF0) marker
    unsigned int i = 0;
    while ((i+1) < mjpg_size && !(mjpg[i] == 0xff && mjpg[i+1] == 0xc0))
        i++;

    // and squeeze huffman table inbetween
    memcpy(jpg,                   mjpg,    i);
    memcpy(jpg+i,                 huffman, sizeof(huffman));
    memcpy(jpg+i+sizeof(huffman), mjpg+i,  mjpg_size-i);
    return jpg_size;
}

unsigned char *read_file(const char *filename, unsigned int *length)
{
    FILE *f = fopen(filename, "rb");
    if (!f)
        return NULL;
    fseek(f, 0, SEEK_END);
    long s = ftell(f);
    fseek(f, 0, SEEK_SET);
    unsigned char *result = (unsigned char*)malloc(s);
    if (fread(result, s, 1, f) != 1)
    {
        fclose(f);
        return NULL;
    }
    fclose(f);
    *length = (unsigned int)s;
    return result;
}

int main()
{
    unsigned int mjpg_size;
    unsigned char *mjpg = read_file("video0000.jpg", &mjpg_size);
    unsigned int jpg_size = mjpg_to_jpg(mjpg, mjpg_size, NULL);
    unsigned char *jpg = (unsigned char*)malloc(jpg_size);
    mjpg_to_jpg(mjpg, mjpg_size, jpg);

    FILE *f = fopen("video0000b.jpg", "w+");
    fwrite(jpg, jpg_size, 1, f);
    fclose(f);
}
